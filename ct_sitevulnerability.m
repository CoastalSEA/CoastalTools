function ct_sitevulnerability(mobj)
%
%-------function help------------------------------------------------------
% NAME
%   ct_sitevulnerability.m
% PURPOSE
%   Compute the beach vulnerability index for a single location
% USAGE
%   ct_sitevulnerability(mobj)
% INPUTS
%   mobj - data handle to CoastalTools UI
% OUTPUT
%   tabular summary of results
% NOTES
%   Uses sholaing.m, runup.m, littoraldrift.m, xshore_bailard.m,
%   profileslope.m, the rate functions in CT_BeachAnalysis.m and the
%   getInWaveModelData function in InWaveModel.m
% SEE ALSO
%   ct_beachvulnearbility.m
%   flist = matlab.codetools.requiredFilesAndProducts('ct_sitevulnerability.m')'
%
% Author: Ian Townend
% CoastalSEA (c)June 2020
%--------------------------------------------------------------------------
%
    if ~license('test','Statistics_Toolbox')  %use prctile from toolbox
        warndlg('Statistics Toolbox needed for BVI model');                      
    end
%     site = mobj.(getClassHandle(mobj,'InWaveSite')); %get site data
    site = mobj.Inputs.ctWaveParameters;
    [data,cobj] = vulnerabilityUI(mobj);  %selected input data            
    if isempty(data), return; end

    bvi = bv_index(data,cobj,site);

    msg1 = sprintf('RMI = mean/(mean+st.dev) = %.2f',bvi.Index(1));
    msg2 = sprintf('CVI = coefficient of variation = %.2f',bvi.Index(2));
    msg3 = sprintf('BVI = beach vulnerability index (based on Alexandrakis et al) = %.2f',bvi.Index(3));
    msg = sprintf('%s\n%s\n%s',msg1,msg2,msg3);

    h_fig = tablefigure('BVI output',msg,bvi); 
end
%%
function indextable = bv_index(data,cobj,site)
%
%-------function help------------------------------------------------------
% NAME
%   bv_index.m
% PURPOSE
%   compute the beach vulnerability index and return table of results
% USAGE
%   indextable = bv_index(data,site)
% INPUTS
%   data - selcted timeseries data set for
%   site - site properties (as defined for Nearshore wave model)
% OUTPUT
%   tabular summary of results
% NOTES
%   loosely follows BVI method of Alexandrakis et al, 2014, Nat.Comms.
%
% Author: Ian Townend
% CoastalSEA (c)June 2020
%--------------------------------------------------------------------------
%
    nstdv = 1;
    %littoral drift indicator
    Qs = data.drift.Qs;
    driftmean = mean(abs(Qs),'omitnan');
    driftstdv = std(abs(Qs),'omitnan');
    driftmax = max(abs(Qs),[],'omitnan');
    drift(1,1) = driftmean/(driftmean+nstdv*driftstdv);
    drift(2,1) = driftstdv/driftmean;
    drift(3,1) = driftmean/driftmax;
    
    %cross-shore transport indicator
    Qx = data.xshor.Qx;
    xshormax = max(abs(Qx),[],'omitnan');
    [xshormnpos,xshormnneg,xshorsdpos,xshorsdneg] = posnegstats(Qx);
    if xshormnpos==0
        Ixp = 0; cvxp = 0;
    else
        Ixp = xshormnpos/(xshormnpos+nstdv*xshorsdpos);
        cvxp = xshorsdpos/xshormnpos;
    end
    xshormnneg = abs(xshormnneg);
    if xshormnneg==0
        Ixn = 0; cvxn = 0;
    else
        Ixn = 1-xshormnneg/(xshormnneg+nstdv*xshorsdneg);
        cvxn = xshorsdneg/xshormnneg;
    end
    xshore(1,1) = (Ixp+Ixn)/2;
    xshore(2,1) = (cvxp+cvxn)/2;
    if (xshormnpos-xshormnneg)<0
        xshore(3,1) = abs(xshormnpos-xshormnneg)/xshormax;
    else
        xshore(3,1) = 0;
    end
    
    %runup relative to crest indicator
    runupmean = mean(data.runup.R2,'omitnan');
    runupstdv = std(data.runup.R2,'omitnan');
    runupzRu = mean(data.runup.zRU,'omitnan');
%     zR = data.runup.zRU;
%     runupzRu = prctile(zR,95,1); %use the 95%tile as basis of index
    runup(1,1) = runupmean/(runupmean+nstdv*runupstdv);
    runup(2,1) = runupstdv/runupmean;
    runup(3,1) = runupzRu/site.BeachCrestLevel;

    %estimate the beach width using water levels and slope
    swl = data.waves.swl;
    HWL = prctile(swl,95);
    LWL = prctile(swl,5);
    meanslope = mean(data.sline.Slope,'omitnan');
    beachwidth = mean((HWL-LWL)*meanslope,'omitnan');
    
    %get the erosion based on positive/negative rates of change
    ero = cobj.TabOutput.table.distSlope;
    [eromnpos,eromnneg,erosdpos,erosdneg] = posnegstats(ero);
    if eromnpos==0
        dxp = 0; cvdxp = 0;
    else
        dxp = eromnpos/(eromnpos+nstdv*erosdpos);
        cvdxp = erosdpos/eromnpos;
    end
    eromnneg = abs(eromnneg);
    if eromnneg==0
        dxn = 0; cvdxn = 0;
    else
        dxn = eromnneg/(eromnneg+nstdv*erosdneg);
        cvdxn = erosdneg/eromnneg;
    end
    %erosion index measures
    delx(1,1) = (dxp+dxn)/2;
    delx(2,1) = (cvdxp+cvdxn)/2;
    eromnnet = eromnpos-eromnneg;
    if eromnnet<0  %use erosion loss over 1 year
        N = 1;   %representative time interval to define vulnerability
        delx(3,1) = abs(eromnnet)*N/beachwidth;
        if delx(3,1)>1, delx(3,1) = 1; end  %upper bound to index
    else
        delx(3,1) = 0;
    end 

    bvi = (drift+xshore+runup+delx)./4;

    indextable = table(drift,xshore,runup,delx,bvi,'VariableNames',...
                        {'Drift','Xshore','Runup','Shoreline','Index'});
end
%%
function [psvmn,negmn,psvstd,negstd] = posnegstats(var)
    %compute the mean and std.dev. for the positive and negative values of
    %a variable
    psvmn = 0; psvstd = 0; negmn = 0; negstd = 0;
    idpos = var>=0;
    if sum(idpos)>0
        psvmn = mean(var(idpos),'omitnan');
        psvstd = std(var(idpos),'omitnan');
    end
    idneg = var<0;
    if sum(idneg)>0
        negmn = mean(var(idneg),'omitnan');
        negstd = std(var(idneg),'omitnan');
    end
end
%%
function [data,cobj] = vulnerabilityUI(mobj)
    %user interface for input selections   
    [inwave,idwv] = getInputOptions(mobj,'ctWaveModel','ModelType','Inwave_model');                                            
    [runup,idru] = getInputOptions(mobj,'CT_WaveModels','ModelType','Runup');                                          
    [drift,iddr] = getInputOptions(mobj,'CT_WaveModels','ModelType','Drift');
    [xshore,idxs] = getInputOptions(mobj,'CT_WaveModels','ModelType','Xshore');
    [shore,idsl] = getInputOptions(mobj,'CT_BeachAnalysis','ModelType','ShoreLine');

    defaultinput ={inwave,drift,xshore,runup,shore};
    ismissing = cellfun(@isempty,defaultinput);
    if any(ismissing)
        warndlg('Wave, Runup, Drift, X-shore and Shoreline models need to be run first')
        data = []; cobj = [];
        return;
    end

    inputxt = {'Waves','Drift','X-shore','Run-up','Shoreline'};
    promptxt = sprintf('Select model runs to use as input');
    nvar = length(inputxt);
    selection = inputgui('FigureTitle', 'BVI input',...
        'InputFields',inputxt,...
        'Style',repmat({'popupmenu'},1,nvar),...
        'ActionButtons',{'Select','Close'},...
        'DefaultInputs',defaultinput,...
        'PromptText',promptxt);
    if isempty(selection), data = []; cobj = []; return; end
    %unpack selections
    data.waves = getDataset(mobj.Cases,idwv(selection{1}),1);  %idset=1
    data.drift = getDataset(mobj.Cases,iddr(selection{2}),1);
    data.xshor = getDataset(mobj.Cases,idxs(selection{3}),1);
    data.runup = getDataset(mobj.Cases,idru(selection{4}),1);
    data.sline = getDataset(mobj.Cases,idsl(selection{5}),1);
    cobj = getCase(mobj.Cases,idsl(selection{5}));  %shoreline object
end
%%
function [casedesc,caserec] = getInputOptions(mobj,classname,propname,propvalue)
    %get a list of descriptions and case rec for available instances
    lobj = getClassObj(mobj,'Cases',classname);
    %check that the minimum number of profiles are available
    if isempty(lobj), return; end
    caseidx = getClassInstances(lobj,propname,propvalue);
    caserec = caseRec(mobj.Cases,caseidx);
    casedesc = mobj.Cases.Catalogue.CaseDescription(caserec);
end