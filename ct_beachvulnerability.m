function [zmtpos,mtstats,indextable,meta] = ct_beachvulnerability(obj,mobj,caserec)
%
%-------function help------------------------------------------------------
% NAME
%   ct_beachvulnerability.m
% PURPOSE
%   Compute the beach vulnerability index over a set of profiles
% USAGE
%   [zmtpos,mtstats,indextable,meta] = ct_beachvulnerability(obj,mobj,caserec)
% INPUTS
%   obj - handle to CT_BeachAnalysis class object
%   mobj - handle to CoastalTools UI
%   caserec - ids pf selected profiles
% OUTPUT
%   zmtpos - position data with E, N, xD, BS, theta
%   mtstats - statistics for position, slope, orientation and rates of change  
%             variables: 'distIntercept','distSlope','distR2','distStdErr',
%             'slopeIntercept','slopeSlope','slopeR2','slopeStdErr'        
%   indextable - tabular summary of results
%   meta - metadata for time and profiles used
% NOTES
%   Uses sholaing.m, runup.m, littoraldrift.m, xshore_bailard.m,
%   profileslope.m, the rate functions in CT_BeachAnalysis.m and the
%   getInWaveModelData function in InWaveModel.m
% SEE ALSO
%   ct_sitevulnearbility.m
%   flist = matlab.codetools.requiredFilesAndProducts('ct_beachvulnerability.m')'
%
% Author: Ian Townend
% CoastalSEA (c)June 2020
%--------------------------------------------------------------------------
%
    indextable = [];
    if ~license('test','Statistics_Toolbox')  %use prctile from toolbox
        warndlg('Statistics Toolbox needed for BVI model');  
        return;
    end
    muicat = mobj.Cases.Catalogue;
    %check inputs----------------------------------------------------------
    proflist = muicat.CaseDescription(caserec); %selected profles
    
    %class instance for inshore wave data
    inwaveobj = mobj.Cases.DataSets.ctWaveModel;
    if isempty(inwaveobj)        
        warndlg('Need set of beach profiles and nearshore wave data');
        return;
    end
    
    nyear = inputdlg('Vulnerability period (years)','BV index',1,{'1'});
    if isempty(nyear), return; end
    Nyear = str2double(nyear);    
    
    site = mobj.Inputs.ctWaveParameters;
    if isempty(site)
        warndlg('Site parameters not defined');
        return; 
    end
    %retrieve an inshore wave data set
    wv = getWaveModelDataset(inwaveobj,mobj,{'Inwave_model'},{'Tp'});
    wvtime = wv.RowNames;
    if isempty(wv), return; end
    
    hw = waitbar(0,'Processing');
    %get dervided variables------------------------------------------------
    %water levels for site
    zHW = prctile(wv.swl,95);
    zLW = prctile(wv.swl,5);
    
    %get various dimensions from profile data
    [ptime,xcrest,zcrest,xmin,zmin] = getCrestLevel(obj,mobj,caserec);
    
    %movement of high water stats
    %function returns pos={E,N,xD,BS,SLang} and struct of regression coefficients
    [zhwpos,hwstats] = getPositionAndRates(obj,mobj,caserec,ptime,zHW,site); 
    %movement of mean tide level (0mOD) stats
    [zmtpos,mtstats] = getPositionAndRates(obj,mobj,caserec,ptime,0,site); 
    %movement of minimum points on profiles stats (zmin) 
    zmint = max(zmin,[],1,'omitnan');
    [~,mnstats] = getPositionAndRates(obj,mobj,caserec,ptime,zmint+0.1,site);  
    xHW = zhwpos{3};                       %distance to high water
    waitbar(0.2,hw)
    
    %extrapolate distance to low water using xHW,zHW,xmin,zmin 
    xLW = (zHW-zLW)./(zHW-zmin).*(xmin-xHW)+xHW;    %distance to low water 
    mnWi = mean((xLW-xHW),1,'omitnan');     %mean width of beach at each profile
    bs = (xLW-xHW)./(zHW-zLW);              %slope of beach
    %interpolate beach slope to get ts to match wave data
    bst = zeros(length(wvtime),size(bs,2));
    for k=1:size(bs,2)
        bst(:,k) = interp1(ptime,bs(:,k),wvtime,'linear','extrap');
    end

    %use the average rate of lateral change (dx/dt) for HW,0,zmin    
    dxdt = (hwstats.distSlope+mtstats.distSlope+mnstats.distSlope)'/3;
    %mean backshore width (xHW-xcrest)
    mnWback = mean((xHW-xcrest),1,'omitnan');
    %mean rate of steepening (dx/dt(HW)-dx/dt(xmin))
    mnWrota = (hwstats.distSlope-mnstats.distSlope)';
    %mean shoreline orientation at each profile
    mntheta = mean(zmtpos{5},1,'omitnan');
    waitbar(0.4,hw)
    
    %compute indices------------------------------------------------------- 
    %beach vulnerability to overflow based on runup
    IRu = getRunupIndex(obj,wv,bst,zcrest);
    waitbar(0.6,hw)
    %beach vulnerability due to horizontal change
    IdX = getLateralChange(obj,dxdt,mnWi,mnWback,Nyear);
    waitbar(0.7,hw)
    %beach vulnerability due to beach steepening/flattening
    IdR = getRotationChange(obj,mnWrota,mnWi,Nyear);
    waitbar(0.8,hw)
    %beach vulnerability due to sediment mobility
    [ISm,formula] = getSedMobility(obj,mobj,wv,bst,mntheta,site);
    waitbar(0.9,hw)
    %beach vulnerability index
    BVI = getBVindex(IRu,IdX,IdR,ISm);
    waitbar(1,hw)
    
    %output table----------------------------------------------------------
    indextable = table(IRu',IdX',IdR',ISm',BVI',...
        'VariableNames',{'Inundation','Erosion','Steepening','Mobility','BVindex'},...
        'RowNames',proflist);
    meta.time = ptime;  meta.proflist = proflist; meta.Nyear = Nyear;
    meta.formula = formula;
    close(hw)
end
%%
function [time,xcrest,zcrest,xmin,zmin] = getCrestLevel(~,mobj,caserec)
    %find the min and max elevations on each profile at each time step
    npro = length(caserec); 
    %get the composite time intervals for all profiles
    [time,dsts] = ProfileTimes(mobj,caserec);
    
    ntime = length(time);    
    zcrest = NaN(ntime,npro);  zmin = zcrest; xmin = zcrest; xcrest = zcrest;    
    for k=1:npro  
        x = dsts(k).Chainage;
        z = dsts(k).Elevation;
        idc = 1:size(x,1);
        [pzmin,idmn] = min(z,[],2);
        [pzmax,idmx] = max(z,[],2);
        ptime = dsts(k).RowNames;  %time intervals for a profile
        idp = find(ismember(time,ptime));   %id of times in profile
        zmin(idp,k) = pzmin;
        idx = sub2ind(size(x),idc',idmn);
        xmin(idp,k) = x(idx);
        zcrest(idp,k) = pzmax;
        idx = sub2ind(size(x),idc',idmx);
        xcrest(idp,k) = x(idx);
    end
end
%%
function IRu = getRunupIndex(~,wv,bst,zcrest)
    %calculate the beach vulnerability to overflow based on runup
    dep1  = 100;           %offshore deep water depth
    %get "effective" deepwater offshore wave conditions               
    Hs0 = shoaling(wv.Hsi,wv.Tp,wv.depi,dep1);  
    %compute runup and convert to elevations relative to OD
    R2 = zeros(size(bst));
    for k=1:size(bst,2)
        bs = bst(:,k);
        R2(:,k) = runup(bs,Hs0,wv.Tp);  
    end
    zR = R2+wv.swl;
    zRpct = prctile(zR,90,1); %use the 90%tile as basis of index
%     IRu = zRpct./min(zcrest,[],1,'omitnan');
    IRu = zRpct./mean(zcrest,1,'omitnan');
end
%%
function IdX = getLateralChange(~,dxdt,mnWint,mnWback,Nyr)
    %beach vulnerability due to horizontal change
    %dxdt - mean rate of loss of shoreline positios at HW, 0 and zmin.
    %(use only erosion as indicated by negative values)
    %mnWint - mean intertidal width
    %mnWback - mean backshore width (crest to HW)
    %Nyr - Vulnerability time period (years)
    
    IdX = -dxdt.*(dxdt<0)./(mnWint+mnWback)*Nyr;
    IdX(IdX>1) = -(mnWint(IdX>1)+mnWback(IdX>1))./dxdt(IdX>1);
end
%%   
function IdR = getRotationChange(~,mnWrota,mnWint,Nyr)
    %beach vulnerability due to beach steepening/flattening
    %mnWrota - mean rate of intertidal steepening based on difference in rate
    %          of lateral change at HW and zmin (use only steepening as
    %          indicated by negative values)
    %mnWint - mean intertidal width    
    %Nyr - Vulnerability time period (years
    IdR = -mnWrota.*(mnWrota<0)./mnWint*Nyr;
    IdR(IdR>1) = -mnWint(IdR>1)./mnWrota(IdR>1);
end
%%
function [ISm,formula] = getSedMobility(~,mobj,wv,bst,theta,site)
    %beach vulnerability due to sediment mobility  
    npro = length(theta);
    nrec = height(wv.DataTable);
    Qall = zeros(nrec,npro,4); Qx = zeros(nrec,npro);
    %bed slope within surf zone (half depth of inshore wave point) 
    ubs = site.UpperBeachSlope;
    z1km = site.BedLevelat1km;            
    bs = profileslope(wv.depi/2,wv.swl,z1km,ubs); %shoreface slope in surf zone

    %call xshore model and add longhshore drift to wave time series
    g = mobj.Constants.Gravity;
    rhw = mobj.Constants.WaterDensity;
    rhs = mobj.Constants.SedimentDensity;
    vsc = mobj.Constants.KinematicViscosity;
    d50 = site.GrainSize;
    Kc = site.DriftCoefficient;
    for k=1:npro
        %NB this uses the shoreface slope bs and NOT the beach slope bst
        Qall(:,k,:) = littoraldrift(wv.Hsi,wv.Tp,wv.Diri,wv.depi,...
                                        theta(k),bs,d50,Kc,g,rhs,rhw,vsc); 
    end
    %user selects which model to use    
    tlist = {'CERC formula (SPM, 1994)',...
             'Dynamics of Marine Sands, Soulsby',...
             'Kamphuis formula',...
             'Damgaard & Soulsby (shingle)'};
    [h_dlg,ok] = listdlg('Name','Plot profile', ...
                         'PromptString','Select formula', ...
                         'ListSize',[200,80], ...
                         'SelectionMode','single', ...
                         'ListString',tlist);
    if ok==0, return; end 
    Qs = Qall(:,:,h_dlg);  
    for k=1:npro
        %NB this uses the beach slope bst and NOT the shoreface slope bs
        Qx(:,k) = xshore_bailard(wv.Hsi,[],[],[],bst(:,k),d50,g,rhw,rhs,vsc);
    end
    sumQ = sum(Qs,1,'omitnan')+sum(Qx,1,'omitnan');
    totQ = sum(abs(Qs),1,'omitnan')+sum(abs(Qx),1,'omitnan');
    ISm = abs(sumQ)./totQ;
    formula = tlist{h_dlg};
end
%%
function BVI = getBVindex(IRu,IdX,IdR,ISm)
    %arithmetic mean of component indices ,with limit on each of 1
        IRu = setLimit(IRu);
        IdX = setLimit(IdX);
        IdR = setLimit(IdR);
        ISm = setLimit(ISm);
        %BVindex as arithmetic mean
        BVI = (IRu+IdX+IdR+ISm)/4;
        
        function var = setLimit(var)
            idx = var>1; 
        if any(idx)
            var(idx) = 1;
        end
    end
end
%%
function [time,dsts] = ProfileTimes(mobj,caserec)
    %get the composite time intervals for all profiles and an array of the
    %datasets (dsts)
    npro = length(caserec);            
    time = [];           %time intervals in any of the surveys
    dsts(npro,1) = dstable;
    for j=1:npro
        dsts(j) = getDataset(mobj.Cases,caserec(j),1); %idset=1
        newtime = dsts(j).RowNames;
        time = unique(vertcat(time,newtime));
    end
end

